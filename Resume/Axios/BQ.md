# 级联下拉框实现项目

## Situation

### 项目背景
* 业务需求
  * 实现城市-学校级联选择
  * 用户选择城市后动态加载学校列表
  * 高并发访问、数据实时性要求中等

### 技术栈
* 前端
  * React + TypeScript
  * Axios（二次封装）
* 后端
  * Java + Spring Boot
  * MyBatis + SQL Server
  * Redis 缓存
  * RabbitMQ 消息队列

## Task

### 个人职责
* 全栈开发
  * 前端组件设计和实现
  * 后端API设计和开发
  * 缓存方案设计
  * 消息队列集成

## Action

### 后端模块设计

1. API模块
* 职责：接口层，处理HTTP请求
* 核心功能：
  * 提供RESTful接口
  * 参数校验和处理
  * 响应封装
  * 异常处理
* 组成部分：
  * Controller：处理请求路由
  * DTO：数据传输对象定义
  * 接口文档（Swagger注解）

2. Domain模块
* 职责：领域层，核心业务逻辑
* 核心功能：
  * 实体定义
  * 业务规则
  * 领域服务
* 组成部分：
  * Entity：领域实体
  * Repository：仓储接口
  * Domain Service：领域服务

3. Infrastructure模块
* 职责：基础设施层，提供技术支持
* 核心功能：
  * 数据访问实现
  * 缓存配置
  * 消息队列配置
* 组成部分：
  * Mapper：MyBatis映射器
  * Cache：Redis缓存服务
  * MQ：RabbitMQ配置和实现
  * Config：各种技术组件配置类

4. Service模块
* 职责：应用服务层，编排业务流程
* 核心功能：
  * 业务流程编排
  * 事务管理
  * 缓存操作
  * 消息发送
* 组成部分：
  * Service实现类
  * 事件处理器
  * 缓存策略
  * 消息队列处理

### 缓存设计
* Redis缓存策略
  * Key设计：school:list:city:${cityId}
  * Value：学校列表的JSON字符串
  * 过期时间：24小时
  * 更新机制：Cache-Aside模式

### 消息队列选型
* 选择RabbitMQ原因
  * 消息量小：学校数据变更频率低
  * 实时性要求适中：秒级同步即可
  * 运维成本低：自带管理界面，配置简单
  * 可靠性有保障：支持消息确认和死信队列

* 不选Kafka原因
  * 过度设计：高吞吐特性在此场景用不上
  * 运维成本高：需要更多服务器资源，配置复杂
  * 学习成本高：对团队技术栈影响大

## Result

### 技术成果
* 性能提升
  * 前端响应更流畅（防抖优化）
  * 后端查询性能提升（Redis缓存）
  * 数据同步可靠（RabbitMQ）

* 代码质量
  * 清晰的模块划分
  * 统一的编码规范
  * 完善的异常处理

### 经验总结
* 技术选型
  * Redis适合查询缓存
  * RabbitMQ适合轻量级消息同步
  * 分层架构提高可维护性

* 最佳实践
  * 统一的接口规范
  * 合理的缓存策略
  * 可靠的消息投递

### 改进方向
* 监控完善
  * 缓存命中率
  * 接口响应时间
  * 消息投递状态
* 异常处理
  * 完善降级策略
  * 优化重试机制